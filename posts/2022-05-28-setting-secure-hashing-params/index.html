<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Setting Secure Hashing Parameters for Password Hashing - Blog</title><meta name=description content="TLDR: As of May 2022, I’d recommend using Argon2Id with the parameters recommended in RFC 9106
 When trying to select the right way to protect your user’s passwords and credentials, there’s two things we need to consider. Firstly, we need to choose the right algorithm, one that is cryptographically secure. Secondly, we need to se the right parameters for the given algorithm to make it behave as securely as possible."><meta name=author content="Rahul Zhade"><link href=https://unpkg.com/@master/normal.css rel=stylesheet><script src=https://unpkg.com/@master/style@1.5.0></script>
<script src=https://unpkg.com/@master/styles@1.13.0></script>
<script src=https://unpkg.com/master-styles-group></script>
<script src=https://unpkg.com/themes.js></script>
<script>window.themes=window.themes||new window.Themes</script><style>:root{--font-sans:"Inter var", ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji}</style></head><body class="bg:fade-84@dark font:fade-16@dark font:sans"><nav class="w:full h:90 fixed bg:fade-84/.95@dark bg:white z:1000"><div class="h:full
w:full
max-w:1200
mx:auto
px:32
d:flex
align-items:center"><div><a href=/ class="mr-3 font:extralight">Blog</a></div><div class=ml:auto></div></div></nav><div class="d:flex flex:column@<=sm pt:90 px:24 jc:center gap:44 word-break:break-word"><div class="max-w:700 w:full box:content-box"><article class="box:border-box pt:32"><header class=mb:32><div class="font:40 font:extrabold">Setting Secure Hashing Parameters for Password Hashing</div><div class="mt:16 f:fade-60"><time>May 28, 2022</time></div></header><div class="_:where(a):hover{text-decoration-color:fade}
_:where(a){text-decoration:2;underline;fade-10;_text-decoration-color:fade-70@dark}
_:where(blockquote){bl:5;solid;fade-76/.1;_bl:5;solid;fade-34/.1@dark}
_:where(code){font:90%;_v:middle}
_:where(code:not(.highlight_*,pre_*)){p:2;6;_r:4}
_:where(del){text-decoration:1;line-through;fade-68;_text-decoration-color:red-64@dark}
_:where(figcaption){text:14;_p:10;20;0;_width:fit;_mx:auto;_font:fade-56;_font:fade-57@dark}
_:where(h1){font:40;_font:extrabold}
_:where(h1,h2,h3)+:where(h1,h2,h3){mt:.5em}
_:where(h1,h2,h3,h4,h5,h6){mt:2em}
_:where(h2){mb:1em;_font:32}
_:where(h3){font:24}
_:where(h4){font:20}
_:where(h5){font:16}
_:where(h6){font:14}
_:where(li)::marker{font:fade-44;_font:fade-68@dark}
_:where(li){pl:.375em}
_:where(mark){text-decoration:1;underline;#fce016;_bg:transparent;_text-decoration-color:rgb(252;224;22/.5)@dark}
_:where(p,li){font:fade-76;_font:16;_line-height:1.65;_font:fade-34@dark}
_:where(p,pre,blockquote,figure,ul,ol,table){my:1.125em}
>:first-child{mt:0!}
_:where(pre){p:20;_r:8;_overflow:auto}
_:where(pre,code:not(.highlight_*)){bg:fade-2;_bg:fade-92!@dark}
_:where(strong,b,a,code:not(.highlight_*),mark,del){font:fade-92;_font:fade-12@dark}
_:where(table){width:full;_border-spacing:0}
_:where(td){v:baseline}
_:where(td,th):first-child{pl:0}
_:where(td,th):last-child{pr:0}
_:where(td,th){bb:1;solid;fade-92/.06;_p:6;_b:fade-4/.04@dark}
_:where(th){font:fade-78;_font:14;_text:left;_font:fade-12@dark}
_:where(th,p_code,li_code,a,mark){font:semibold;_font:medium@dark}
_:where(ul){list-style-type:disc}
_:where(ul,ol,blockquote){pl:1.5em}
_:where(video,img){max-width:full}
_:where(a,mark){text-underline-offset:3}
_:where(hr){h:2;_bg:fade-10;_bg:fade-70@dark;_my:3em}"><blockquote><p>TLDR: As of May 2022, I’d recommend using Argon2Id with the parameters recommended in <a href=https://www.rfc-editor.org/rfc/rfc9106.html>RFC 9106</a></p></blockquote><p>When trying to select the right way to protect your user’s passwords and credentials, there’s two things we need to consider. Firstly, we need to choose the right algorithm, one that is cryptographically secure. Secondly, we need to se the right <em>parameters</em> for the given algorithm to make it behave as securely as possible.</p><p>Secure behavior for a hashing function means that, in addition to being cryptographically secure, it should also be as resource intensive as possible. This will help prevent brute force attacks in the event that your database is breached and the hashes are leaked. The longer it takes for you to verify a password’s hash, the longer it’ll take an attacker to try to guess what the user’s password is based on the hash<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><blockquote><p>Use a hashing algorithm that is CPU intensive and not parallelizable on GPUs</p></blockquote><p>There’s a couple good options that meet these criteria; <code>Argon2</code>, <code>bcrypt</code>, and <code>pbkdf2</code>. I would advise using Argon2Id as it’s hard to parallelize on GPUs, compute intensive, and easy to customize in most implementations.</p><p>The second step is to set the right parameters for your chosen algorithm. To make the hashing easier or harder for an attacker, we can customize the behavior of the hashing algorithm by passing it different parameters.</p><blockquote><p>Hashing a password should take around 0.25 seconds, using as much CPU power and threads as you are able to provide.</p></blockquote><h2 id=parameters>Parameters</h2><p>In the case of <code>bcrypt</code> and <code>pbkdf2</code>, these parameters are the number of rounds that we run for. For example, two rounds of <code>pbkdf2</code> is the equivalent of running <code>pbkdf2(pbkdf2(password))</code>, similar for bcrypt.</p><p>For Argon2, there’s more available options. We can set the number of cores, or the amount of CPU intensity it takes.</p><p>Now, how do we find out which params to use? Essentially, you want to tweak the parameters until you find something that meets your requirements (0.25 seconds + compute intensive). I’ve written a command line tool that you can run on your production infrastructure to find out the best parameters for your particular environment, check it out at <a href=https://github.com/rzhade3/hash-metrics><code>rzhade3/hash-metrics</code></a>.</p><p>In case you don’t want to run this script, and just want general guidance, consult the following table.</p><p>Up to date as of May 2022</p><table><thead><tr><th>Algorithm</th><th>Rounds</th></tr></thead><tbody><tr><td>pbkdf2_sha256</td><td>400000</td></tr><tr><td>pbkdf2_sha512</td><td>300000</td></tr><tr><td>bcrypt</td><td>12</td></tr></tbody></table><p>However, your work isn’t done once you’ve selected the right params, as hardware keeps getting better every year! You need to ensure that your algorithm continues to remain secure, and that your parameters still provide adequate brute force protection on modern hardware.</p><h2 id=pointers>Pointers</h2><p>To future proof your implementation, I’d recommend a few follow up steps:</p><ol><li>Use a hash algorithm implementation that takes as input a <em>time cost</em> and <em>memory cost</em>, which will recalculate its own internal parameters to make sure that it’s always running with as many resources as possible.<ul><li>This will make things much easier on your part, as if you do this, you will not need to worry about Step 3. As long as your production infrastructure is upgraded reasonably frequently, your users will be protected according to industry standards.</li></ul></li><li>Store your hashing parameters in your database alongside your passwords<ul><li>Given that you may change your hashing parameters in the future, it’s important to store what the current state of affairs is in your database. This will help you update them in the future.</li><li>For example, you can store the password like this:<ul><li><code>{algorithm=pbkdf}${param1=1},{param2=2}${hash}</code></li></ul></li></ul></li><li>If you’re not using an implementation that uses a time cost or CPU cost, routinely reevaluate your parameters to check if they’re still intensive.<ul><li>Moore’s law states that hardware doubles in power every 2 years. As such, you should re-evaluate your parameters on a 2 year cadence to ensure that it is still correct for your use case.</li></ul></li></ol><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This is assuming that we’ve properly salted our creds, otherwise we’d still be vulnerable to Rainbow table lookups&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article><footer class=py:24><div class="f:fade-30 f:14 mb:8"></div><div class="f:fade-60 f:12">Theme <a class=f:bold href=https://github.com/serkodev/holy _target=_blank>Holy</a></div></footer></div></div></body></html>