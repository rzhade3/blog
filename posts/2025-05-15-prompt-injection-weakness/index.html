<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Prompt Injection is a Weakness, not a Vulnerability - Blog</title><meta name=description content="Prompt injection is the most widely discussed emergent threat for Large Language Models (LLMs). But how should organizations approach tracking and prioritizing it?
In my opinion, instead of being a vulnerability in and of itself, prompt injection is a weakness that leads to other, more potent vulnerabilities. While it is true that prompt injection is undesirable, it doesn’t necessarily lead to any business value compromises and is also (at the time of writing) unsolvable."><meta name=author content="Rahul Zhade"><link href=https://unpkg.com/@master/normal.css rel=stylesheet><script src=https://unpkg.com/@master/style@1.5.0></script>
<script src=https://unpkg.com/@master/styles@1.13.0></script>
<script src=https://unpkg.com/master-styles-group></script>
<script src=https://unpkg.com/themes.js></script>
<script>window.themes=window.themes||new window.Themes</script><style>:root{--font-sans:"Inter var", ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji}</style></head><body class="bg:fade-84@dark font:fade-16@dark font:sans"><nav class="w:full h:90 fixed bg:fade-84/.95@dark bg:white z:1000"><div class="h:full
w:full
max-w:1200
mx:auto
px:32
d:flex
align-items:center"><div><a href=/ class="mr-3 font:extralight">Blog</a></div><div class=ml:auto></div></div></nav><div class="d:flex flex:column@<=sm pt:90 px:24 jc:center gap:44 word-break:break-word"><div class="max-w:700 w:full box:content-box"><article class="box:border-box pt:32"><header class=mb:32><div class="font:40 font:extrabold">Prompt Injection is a Weakness, not a Vulnerability</div><div class="mt:16 f:fade-60"><time>May 15, 2025</time></div></header><div class="_:where(a):hover{text-decoration-color:fade}
_:where(a){text-decoration:2;underline;fade-10;_text-decoration-color:fade-70@dark}
_:where(blockquote){bl:5;solid;fade-76/.1;_bl:5;solid;fade-34/.1@dark}
_:where(code){font:90%;_v:middle}
_:where(code:not(.highlight_*,pre_*)){p:2;6;_r:4}
_:where(del){text-decoration:1;line-through;fade-68;_text-decoration-color:red-64@dark}
_:where(figcaption){text:14;_p:10;20;0;_width:fit;_mx:auto;_font:fade-56;_font:fade-57@dark}
_:where(h1){font:40;_font:extrabold}
_:where(h1,h2,h3)+:where(h1,h2,h3){mt:.5em}
_:where(h1,h2,h3,h4,h5,h6){mt:2em}
_:where(h2){mb:1em;_font:32}
_:where(h3){font:24}
_:where(h4){font:20}
_:where(h5){font:16}
_:where(h6){font:14}
_:where(li)::marker{font:fade-44;_font:fade-68@dark}
_:where(li){pl:.375em}
_:where(mark){text-decoration:1;underline;#fce016;_bg:transparent;_text-decoration-color:rgb(252;224;22/.5)@dark}
_:where(p,li){font:fade-76;_font:16;_line-height:1.65;_font:fade-34@dark}
_:where(p,pre,blockquote,figure,ul,ol,table){my:1.125em}
>:first-child{mt:0!}
_:where(pre){p:20;_r:8;_overflow:auto}
_:where(pre,code:not(.highlight_*)){bg:fade-2;_bg:fade-92!@dark}
_:where(strong,b,a,code:not(.highlight_*),mark,del){font:fade-92;_font:fade-12@dark}
_:where(table){width:full;_border-spacing:0}
_:where(td){v:baseline}
_:where(td,th):first-child{pl:0}
_:where(td,th):last-child{pr:0}
_:where(td,th){bb:1;solid;fade-92/.06;_p:6;_b:fade-4/.04@dark}
_:where(th){font:fade-78;_font:14;_text:left;_font:fade-12@dark}
_:where(th,p_code,li_code,a,mark){font:semibold;_font:medium@dark}
_:where(ul){list-style-type:disc}
_:where(ul,ol,blockquote){pl:1.5em}
_:where(video,img){max-width:full}
_:where(a,mark){text-underline-offset:3}
_:where(hr){h:2;_bg:fade-10;_bg:fade-70@dark;_my:3em}"><p>Prompt injection is the most widely discussed emergent threat for Large Language Models (LLMs). But how should organizations approach tracking and prioritizing it?</p><p>In my opinion, instead of being a vulnerability in and of itself, prompt injection is a weakness that leads to other, more potent vulnerabilities. While it is true that prompt injection is undesirable, it doesn’t necessarily lead to any business value compromises and is also (at the time of writing) unsolvable. As such, it is better to treat it as a necessary side effect of using LLMs, architect around it, and not track it as a distinct vulnerability.</p><h2 id=vulnerabilities-vs-weaknesses>Vulnerabilities vs Weaknesses</h2><p>In cybersecurity, a weakness is a flaw in a system that can increase the likelihood of the system being exploited, but not necessarily <em>cause</em> an exploit. A vulnerability is a weakness that <em>can be exploited</em>. <strong>The key difference is that vulnerabilities are directly exploitable; weaknesses may not be.</strong></p><p>Weaknesses <em>can lead to</em> vulnerabilities, but the weakness itself is not typically tracked within a vulnerability management system. As such, deciding to treat prompt injection as a weakness has heavy implications as to how your organization manages and resolves it as a risk.</p><h2 id=what-is-prompt-injection>What Is Prompt Injection?</h2><p>Prompt injection occurs when someone manipulates input to a language model to alter its behavior in unintended ways—whether by injecting malicious instructions or bypassing established controls. The challenge lies in defining what &ldquo;unintended&rdquo; actually means, as developers and end users often have different intentions for how an LLM should function.</p><h2 id=why-isnt-prompt-injection-an-issue>Why Is(n’t) Prompt Injection an issue?</h2><p>Prompt injection can lead to an LLM producing “poisoned” content. This can have a few effects: leaking or bypassing of a system prompt, a malicious directive for a tool call, leaking of authorized content, inducing an MCP client to issue incorrect directives, etc.</p><p>However, all of these are issues for different reasons:</p><ul><li>Leaking or bypassing a system prompt is unsafe when a system prompt contains sensitive content or is the only guardrail that prevents malicious behavior. This is, unfortunately, an issue due to <strong>prompt injection itself</strong>.</li><li>Poisoned outputs are unsafe when they’re unsafely interpolated into something else. For example, injecting the output of an LLM directly into a shell command can lead to command injection, or into a UI can lead to XSS. This is an issue due to <strong>insecure output handling</strong>.</li><li>Leaking authorized content is unsafe when an LLM has access to content that a user otherwise does not have access to. This is an issue due to <strong>improper authorization</strong>.</li><li>Inducing an MCP client to select an incorrect directive is unsafe due to it making tool calls with inadequate <a href=https://en.wikipedia.org/wiki/Human-in-the-loop>human-in-the-loop controls</a>. This is a complex problem, but one that ultimately occurs due to the <strong>confused deputy problem</strong>.</li></ul><p>Setting aside the first vulnerability (where prompt injection directly exposes or bypasses sensitive system prompts) above, let’s discuss why the other issues are not intrinsic to LLMs themselves.</p><p>An LLM, in a system diagram, <em>has no dependencies</em> and is <em>incapable of any external behavior</em>. It is just a black box that accepts some text as input, and spits out some text as output. As such, the only vulnerability that an LLM <em>natively</em> is capable of is leaking any context that is passed to it. Any capabilities that are bolted on to an LLM (MCP, Agents, etc.) are <em>independent</em> of the LLM itself. Any vulnerabilities in these external components should be considered vulnerabilities in the components themselves, not in the LLM.</p><p>It helps to threat model an LLM as an untrusted user. Accepting arbitrary user input is not necessarily a vulnerability— how you <em>treat</em> the user input is what causes risk. If you wouldn’t trust an arbitrary user to run shell commands on your server, or input HTML onto your page, or issue API commands on your behalf, why would you treat an AI any differently? You should apply output sanitization, add human-in-the-loop controls and monitoring, add authorization controls, and firewall appropriately.</p><p>This does bring us back to the first point though: leaking of sensitive context or bypassing restrictions set by the system prompt. While prompt injection can exploit such weaknesses, relying on system prompts for security is fundamentally fragile—primarily because of natural language&rsquo;s intrinsic ambiguity, which makes robust intent enforcement nearly impossible.</p><h2 id=the-challenge-in-robustly-addressing-prompt-injections-natural-language-ambiguity>The Challenge in Robustly Addressing Prompt Injections: Natural Language Ambiguity</h2><p>The challenge in determining intention is that there is <em>inherent ambiguity in natural language</em>. For example, take a look at this sentence:</p><blockquote><p>He saw her duck.</p></blockquote><p>Is &ldquo;duck&rdquo; a noun or a verb? The meaning is only clear when you add additional context. This problem compounds when you have larger prompts, and especially when you have multiple users defining context, such as the developer of an AI app, a user, and potentially even MCP integrations.</p><p>For example, let’s say that an AI Agent is prompt injected into installing a malicious dependency. Can you definitively prove that the end user didn’t want this action? The lack of a domain-specific language for LLM interactions (comparable to programming languages) makes intent verification fundamentally intractable.</p><p>Existing mechanisms for mitigating prompt hardening (such as input and output filtering, prompt hardening, intent classification, and retrieval augmentation) try to increase context and thus alignment to a particular domain. However, all of these are nondeterministic and, more importantly, do not solve the fundamental issue of ambiguity in prompting.</p><p>As such, in my opinion, it is infeasible, in the near future, to solve the AI alignment problem, and thus prompt injection at large, with better system prompts. Given this, we must reconsider how we approach managing prompt injection—not as a solvable vulnerability but as a persistent weakness that needs to be architected around.</p><h2 id=managing-prompt-injection>Managing Prompt Injection</h2><p>From a theoretical perspective, the only inherent risk posed by prompt injection is the bypassing or leaking of the system prompt. All other risks and vulnerabilities are due to downstream behaviors that are <em>enabled</em> by prompt injection.</p><blockquote><p>Prompt injection is the <em>weakness</em> that leads to data exfiltration, spoofed MCP tool calls, and leaking of authorized content, not the vulnerability itself.</p></blockquote><p>From a practical standpoint, treating prompt injection itself as a vulnerability creates problems. Tracking vulnerabilities in a security program should ideally imply that adequate mitigations exist. If not, these vulnerabilities must ultimately be continually risk-accepted. This will lead to:</p><ul><li>Executive fatigue from continual security alerts,</li><li>Engineering resources wasted on unsolvable problems,</li><li>Diminished attention to addressable security concerns</li></ul><p>Prompt injection alone doesn&rsquo;t necessarily compromise business value if systems are designed properly. Prompt injection is best addressed with proper product design:</p><ul><li>Unauthorized Command Injection and XSS can be resolved with output sanitization.</li><li>Data exfiltration can be resolved with firewalling and human-in-the-loop controls.</li><li>The Confused Deputy Problem can be mitigated with <a href=https://medium.com/data-science-collective/mcp-is-a-security-nightmare-heres-how-the-agent-security-framework-fixes-it-fd419fdfaf4e>the Agent Security Framework</a> and human-in-the-loop controls.</li></ul><p>If product designs are insecure, the business risk results from any of the above downstream vulnerabilities. Furthermore, it’s much easier for an executive or engineer to understand the business value risk from a data exfiltration issue than from the more abstract prompt injection. There is a direct value compromise caused by the data exfiltration, whereas a prompt injection may or may not lead to any financial or reputational impact.</p><p>With these points in mind, here are some practical recommendations for addressing prompt injection in your organization:</p><h2 id=recommendations>Recommendations</h2><p>For those responsible for AI security:</p><ol><li><strong>Track downstream impacts separately</strong> - Focus on the specific vulnerabilities that prompt injection enables rather than treating prompt injection itself as the primary issue.</li><li><strong>Improve underlying models</strong> - Continue advancing the state-of-the-art in prompt injection mitigation, but with realistic expectations about what&rsquo;s possible.</li><li><strong>Rethink confidentiality assumptions</strong> - Don&rsquo;t consider system prompts confidential, as prompt injection cannot be robustly mitigated anyway. Architect your systems assuming that any context provided to the LLM will be revealed to an end user.</li></ol><p>By shifting focus to the concrete business risks that stem from insecure LLM design patterns rather than the abstract concept of prompt injection itself, security teams can make meaningful progress in protecting AI systems while using resources efficiently.</p><p><em><strong>Edits:</strong> Edits were made to the original for additional clarity, see <a href=https://github.com/rzhade3/blog/commits/main/>the commit history</a> for the original version.</em></p></div></article><footer class=py:24><div class="f:fade-30 f:14 mb:8"></div><div class="f:fade-60 f:12">Theme <a class=f:bold href=https://github.com/serkodev/holy _target=_blank>Holy</a></div></footer></div></div></body></html>